let globCaptureRegex;

beforeEach(() => {
    globCaptureRegex = require('..');
});

test('the default export should be a function', () => {
    expect(globCaptureRegex).toBeInstanceOf(Function);
});

describe('globCaptureRegex function returns an object with 3 properties:', () => {
    let result;
    beforeAll(() => {
        const str = 'Hello World';
        result = globCaptureRegex(str);
    })

    test('the object should be an instance of Object', () => {
        expect(result).toBeInstanceOf(Object);
    });

    test('the object should have 3 properties', () => {
        expect(Object.keys(result).length).toBe(3);
    });

    test('the object should contain a getter named regex which returns a RegExp object', () => {
        expect(result.regex).toBeInstanceOf(RegExp);
    })

    test('the object should contain a getter named glob which returns a string', () => {
        expect(typeof result.glob).toBe('string');
    })

    test('the object should contain a property named parse which is a function', () => {
        expect(result.parse).toBeInstanceOf(Function);
    })
});

test('the regular expression generated by globCaptureRegex function should match the input string', () => {
    const text = 'This is (glob) (pattern (without) using glob wildcard)';
    const result = globCaptureRegex(text);

    expect(result.regex).toBeInstanceOf(RegExp);
    expect(result.regex).toEqual(new RegExp(`^${text}$`));
});

test('the glob pattern generated by globCaptureRegex function should be equal to the input string', () => {
    const text = 'This is * glob pattern without using groups';
    const result = globCaptureRegex(text);

    expect(typeof result.glob).toBe('string');
    expect(result.glob).toBe(text);
});


test('balanced parenthesis shouldn\'t cause an error', () => {
    for (let i = 0; i < 100; ++i) {
        const balanced = randomTextWithBalancedParenthesis();
        expect(() => globCaptureRegex(balanced)).not.toThrowError();
    }
});

test('unbalanced parenthesis should cause an error', () => {
    for (let i = 0; i < 100; ++i) {
        const balanced = randomTextWithBalancedParenthesis();
        const position = Math.floor(Math.random() * balanced.length + 1);
        const parenthesis = Math.random() < 0.5? '(' : ')';
        const unbalanced = balanced.slice(0, position) + parenthesis + balanced.slice(position); 

        expect(() => globCaptureRegex(unbalanced)).toThrowError();
    }
});

test('example shown in README.md', () => {
    const globWithGroups = 'my/gl(*)b/pattern/(**).js';
    const path = 'my/glob/pattern/with/capture/groups.js';

    const { glob, regex } = globCaptureRegex(globWithGroups).parse();

    expect(glob).toBe('my/gl*b/pattern/**.js');

    const expected = [
        'my/glob/pattern/with/capture/groups.js',
        'o',
        'with/capture/groups',
    ];
    path.match(regex).forEach((match, i) => {
        expect(match).toEqual(expected[i]);
    });
});

test('behavior againt random generated test and patterns', () => {
    const examplesCount = 1_000;

    const getMaxLength = (index, arrayLength) => [0, arrayLength - 1].includes(index) ? 3 : 12;

    for (let i = 0; i < examplesCount; i++) {

        const txtLength = 7;
        const txt = Array(txtLength).fill(null).map((_, i) => randomText({
            maxLength: getMaxLength(i, txtLength),
            excludeChars: '()\\*',
        }));

        const value1 = randomText();
        const value2 = randomText({ excludeChars: '()\\*' });
        const value3 = randomText();

        const text = `${txt[0]}${value1}/${txt[1]}${value2}/${txt[2]}${value3}${txt[3]}${txt[4]}${txt[5]}${txt[6]}`;
        const globPattern = `${txt[0]}((*)/${txt[1]}**/${txt[2]}*${txt[3]})${txt[4]}(${txt[5]})${txt[6]}`;

        const regex = globCaptureRegex(globPattern).regex;
        const groups = text.match(regex);

        expect(groups[0]).toBe(text);
        expect(groups[1]).toBe(`${value1}/${txt[1]}${value2}/${txt[2]}${value3}${txt[3]}`);
        expect(groups[2]).toBe(value1);
        expect(groups[3]).toBe(txt[5]);
    }
});

function randomText({ minLength = 0, maxLength = 10, excludeChars = "()/\\*" } = {}) {
    let randomText = '';
    const textLength = Math.floor(Math.random() * (maxLength - minLength + 1));

    const asciiRange = [32, 127];
    const chars = Array(asciiRange[1] - asciiRange[0])
        .fill(asciiRange[0])
        .map((code, i) => code + i)
        .map(code => String.fromCharCode(code))
        .filter(char => !excludeChars.includes(char))
        .join('');

    for (let i = 0; i < textLength; i++) {
        randomText += chars[Math.floor(Math.random() * chars.length)];
    }

    return randomText;
}

function randomTextWithBalancedParenthesis() {
    const parenthesis = Math.floor(Math.random() * 5);

    let opened = 0;
    let closed = 0;
    let text = randomText();
    for (let i = 0; i < parenthesis * 2; i++) {
        const openNew = (opened + closed) < parenthesis && (Math.random() < 0.5 || opened == 0);
        opened = openNew ? opened + 1 : opened - 1;
        closed += !openNew;
        text += openNew ? '(' : ')';

        text += randomText();
    }

    return text;
}
